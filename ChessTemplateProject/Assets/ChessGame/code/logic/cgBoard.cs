using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System;

/// <summary>
/// The chess board, here moves are generated, checked for legality, performed and reverted.
/// </summary>
public class cgBoard
{
    #region properties / fields
    /// <summary>
    /// The 0-64 index presentation of the board. This is where the magic happends. Below is a detailed list of what values can be expected, and what each index position corresponds to on the board.
    /// </summary>
    public List<sbyte> squares = new List<sbyte>(64);
    /**
     * 0 = unoccupied square
     * 
     * 1 = white pawn
     * 2 = white rook
     * 3 = white knight
     * 4 = white bishop
     * 5 = white queen
     * 6 = white king
     * 
     * -1 = black pawn
     * -2 = black rook
     * -3 = black knight
     * -4 = black bishop
     * -5 = black queen
     * -6 = black king
     * 
     * 
       0  1  2  3  4  5  6  7
    *  8  9  10 11 12 13 14 15
    *  16 17 18 19 20 21 22 23
    *  24 25 26 27 28 29 30 31
    *  32 33 34 35 36 37 38 39 
    *  40 41 42 43 44 45 46 47
    *  48 49 50 51 52 53 54 55
    *  56 57 58 59 60 61 62 63
    * *
     * */

    /// <summary>
    /// A list of all unreverted moves in chronological order since the start of the game.
    /// </summary>
    public List<cgSimpleMove> moves = new List<cgSimpleMove>();

    /// <summary>
    /// Total number of moves that have been performed(regardless of reverting).
    /// </summary>
    public int moveCount = 0;

    /// <summary>
    /// Total number of reverts that have been performed.
    /// </summary>
    public int revertCount = 0;


    /// <summary>
    /// Has white castled? used to add value on board avaluation.
    /// </summary>
    public bool whiteHasCastled = false;

    /// <summary>
    /// Has black castled? used to subtract value on board avaluation.
    /// </summary>
    public bool blackHasCastled = false;

    /// <summary>
    /// The index of a square on which there a pawn can perform an en passant move to. If you've never heard of en passant - google it, its a rare type of pawn move that occurs in highly circumstantial situations.
    /// </summary>
    private byte _enPassantSquare = 0;

    /// <summary>
    /// The capturing square for a pawn performing en passant.
    /// </summary>
    private byte _enPassantCapturesOn = 0;

    /// <summary>
    /// Is it whites turn to move?
    /// </summary>
    private bool _whiteTurnToMove = true;

    /// <summary>
    /// number of times the white rook starting on the A file has moved - used to store long castling rights.
    /// </summary>
    private byte _whiteARookMoves = 0;

    /// <summary>
    /// number of times the white rook starting on the H file has moved - used to store short castling rights.
    /// </summary>
    private byte _whiteHRookMoves = 0;

    /// <summary>
    /// number of times the black rook starting on the A file has moved - used to store long castling rights.
    /// </summary>
    private byte _blackARookMoves = 0;

    /// <summary>
    /// number of times the black rook starting on the H file has moved - used to store short castling rights.
    /// </summary>
    private byte _blackHRookMoves = 0;

    /// <summary>
    /// number of times the white king has moved used to to store short and long castling rights.
    /// </summary>
    private byte _whiteKingMoves = 0;

    /// <summary>
    /// number of times the black king has moved used to store short and long castling rights.
    /// </summary>
    private byte _blackKingMoves = 0;

    /// <summary>
    /// Is it whites turn to move?
    /// </summary>
    public bool whiteTurnToMove
    {
        get { return _whiteTurnToMove; }
    }

    /// <summary>
    /// All possible moves generated by MoveGenerator, stored by an identifying string using the format (piecetype)+(indexpostion)
    /// </summary>
    private static Dictionary<string, cgMoveSet> allHypotheticalMoves = null;

    /// <summary>
    /// The default starting position.
    /// </summary>
    public static List<sbyte> defaultStartPosition = new List<sbyte> {
            -2, -3, -4, -5, -6, -4, -3, -2,
            -1, -1, -1, -1, -1, -1, -1, -1,
             0,  0,  0,  0,  0,  0,  0,  0,
             0,  0,  0,  0,  0,  0,  0,  0,
             0,  0,  0,  0,  0,  0,  0,  0,
             0,  0,  0,  0,  0,  0,  0,  0,
             1,  1,  1,  1,  1,  1,  1,  1,
             2,  3,  4,  5,  6,  4,  3,  2
            };

    /// <summary>
    /// Create a new instance of the board.
    /// </summary>
    /// <param name="positions"></param>
    #endregion

    public cgBoard(List<sbyte> positions = null)
    {
        if (positions != null) squares = positions;
        else
        {
            foreach (sbyte sb in defaultStartPosition) squares.Add(sb);
        }

        if (allHypotheticalMoves == null) _generateAllPossibleMoves();

    }

    /// <summary>
    /// Perform the provided move, capturing if necessary.
    /// </summary>
    /// <param name="move">The move to perform.</param>
    public void move(cgSimpleMove move)
    {
        moves.Add(move);
        moveCount++;
        if (move.to == 65) return;
        move.capturedType = squares[move.to];
        squares[move.to] = squares[move.from];
        squares[move.from] = 0;
        //_enPassantSquare = 0;
        //Pawn auto-promote to queen
        if (move.to < 8 && squares[move.to] == 1)
        {
            move.queened = true;
            squares[move.to] = 5;
        }
        else if (move.to > 55 && squares[move.to] == -1)
        {
            move.queened = true;
            squares[move.to] = -5;
        }
        if (move is cgCastlingMove)
        {
            //if move is castling there is a secondary move to also perform.
            squares[(move as cgCastlingMove).secondTo] = squares[(move as cgCastlingMove).secondFrom];
            squares[(move as cgCastlingMove).secondFrom] = 0;
            if (_whiteTurnToMove) whiteHasCastled = true;
            else blackHasCastled = true;
        }
        else if (move is cgEnPassantMove)
        {
            move.capturedType = squares[(move as cgEnPassantMove).attackingSquare];
            squares[(move as cgEnPassantMove).attackingSquare] = 0;
        }
        if (squares[move.to] == -2 && move.from == 0) _blackARookMoves++;
        else if (squares[move.to] == -2 && move.from == 7) _blackHRookMoves++;
        else if (squares[move.to] == 2 && move.from == 56) _whiteARookMoves++;
        else if (squares[move.to] == 2 && move.from == 63) _whiteHRookMoves++;
        //if(squares[move.to]==1)
        if (squares[move.to] == 6) _whiteKingMoves++;
        else if (squares[move.to] == -6) _blackKingMoves++;

        _whiteTurnToMove = !_whiteTurnToMove;

    }

    /// <summary>
    /// Does the provided color still have its long castling rights?
    /// </summary>
    /// <param name="white">The color whoms castling right should be checked,false=black</param>
    /// <returns>Does still have its long castling rights?</returns>
    public bool longCastlingRights(bool white)
    {
        if (white) return (_whiteKingMoves == 0 && _whiteARookMoves == 0 && !whiteHasCastled);
        else return (_blackKingMoves == 0 && _blackARookMoves == 0 && !blackHasCastled);
    }

    /// <summary>
    /// Does the provided color still have its short castling rights?
    /// </summary>
    /// <param name="white">The color whoms castling right should be checked,false=black</param>
    /// <returns>Does still have its short castling rights?</returns>
    public bool shortCastlingRights(bool white)
    {
        if (white) return (_whiteKingMoves == 0 && _whiteHRookMoves == 0 && !whiteHasCastled);
        else return (_blackKingMoves == 0 && _blackHRookMoves == 0 && !blackHasCastled);
    }

    /// <summary>
    /// Revert the last performed move.
    /// </summary>
    public void revert()
    {
        if (moves.Count > 0)
        {
            revertCount++;
            if (moves[moves.Count - 1].to == 65)
            {
                moves.RemoveAt(moves.Count - 1);
                return;
            }
            //revert piwce placement and add previously captured piece on departing square(if not an enpassant move)
            squares[moves[moves.Count - 1].from] = squares[moves[moves.Count - 1].to];
            if (moves[moves.Count - 1] is cgEnPassantMove)
            {
                squares[(moves[moves.Count - 1] as cgEnPassantMove).attackingSquare] = (sbyte)(moves[moves.Count - 1] as cgEnPassantMove).capturedType;
                squares[(moves[moves.Count - 1] as cgEnPassantMove).to] = 0;
            }
            else squares[moves[moves.Count - 1].to] = moves[moves.Count - 1].capturedType;

            //if move was a pawn getting queened then revert the piece back to pawn aswell.
            if (moves[moves.Count - 1].queened)
            {
                //bool white = squares[moves[moves.Count - 1].from] > 0 ? true : false;
                squares[moves[moves.Count - 1].from] = (sbyte)(moves[moves.Count - 1].from > 30 ? -1 : 1);
            }

            //if piece is rook register its moves for castling rights purposes.
            if (squares[moves[moves.Count - 1].from] == -2 && moves[moves.Count - 1].from == 0) _blackARookMoves--;
            else if (squares[moves[moves.Count - 1].from] == -2 && moves[moves.Count - 1].from == 7) _blackHRookMoves--;
            else if (squares[moves[moves.Count - 1].from] == 2 && moves[moves.Count - 1].from == 56) _whiteARookMoves--;
            else if (squares[moves[moves.Count - 1].from] == 2 && moves[moves.Count - 1].from == 63) _whiteHRookMoves--;

            //If piece is king register its moves for castling rights purposes
            if (squares[moves[moves.Count - 1].from] == 6) _whiteKingMoves--;
            else if (squares[moves[moves.Count - 1].from] == -6) _blackKingMoves--;

            if (moves[moves.Count - 1] is cgCastlingMove)
            {
                squares[(moves[moves.Count - 1] as cgCastlingMove).secondFrom] = squares[(moves[moves.Count - 1] as cgCastlingMove).secondTo];
                squares[(moves[moves.Count - 1] as cgCastlingMove).secondTo] = 0;
                if (!_whiteTurnToMove) whiteHasCastled = false;
                else blackHasCastled = false;
            }

            //Debug.Log("reverted " + pceGlobal.CellNames[moves[moves.Count - 1].to] + "->" + pceGlobal.CellNames[moves[moves.Count - 1].from]+" squares now occupied there:"+squares[moves[moves.Count-1].to]+" & "+squares[moves[moves.Count-1].from]);
            moves.RemoveAt(moves.Count - 1);
            _whiteTurnToMove = !_whiteTurnToMove;
        }
    }

    /// <summary>
    /// Write to the debug a human readable version of the current squares.
    /// </summary>
    public void debugReadBoard()
    {
        string str = "";
        for (int i = 0; i < squares.Count; i++)
        {
            str += " [" + (squares[i] < 0 ? "" : " ") + squares[i] + "] ";
            if ((i + 1) % 8 == 0) str += "\n";
        }
        str += " En passant at:" + _enPassantSquare + " white has castled:" + whiteHasCastled + " black has castled:" + blackHasCastled + " black has long cast rights:" + longCastlingRights(false) + " black has short castling rights." + shortCastlingRights(false);
        UnityEngine.Debug.Log(str + ", count." + squares.Count);
    }

    /// <summary>
    /// Evaluate the current board, adding together material values of both sides, positional values, castling values etc.
    /// </summary>
    public int Evaluate()
    {
        int lazyVal = 0;
        for (int i = 0; i < squares.Count; i++)
        {
            switch (squares[i])
            {
                case 0:
                    continue;
                case 1:
                    lazyVal += cgValueModifiers.Value_Pawn;
                    lazyVal += cgValueModifiers.Positions_Pawn[i];
                    break;
                case 2:
                    lazyVal += cgValueModifiers.Value_Rook;
                    lazyVal += cgValueModifiers.Positions_Rook[i];
                    break;
                case 3:
                    lazyVal += cgValueModifiers.Value_Knight;
                    lazyVal += cgValueModifiers.Positions_Knight[i];
                    break;
                case 4:
                    lazyVal += cgValueModifiers.Value_Bishop;
                    lazyVal += cgValueModifiers.Positions_Bishop[i];
                    break;
                case 5:
                    lazyVal += cgValueModifiers.Value_Queen;
                    break;
                case 6:
                    lazyVal += cgValueModifiers.Value_King;
                    break;
                case -1:
                    lazyVal -= cgValueModifiers.Value_Pawn;
                    lazyVal -= cgValueModifiers.Positions_Pawn[i];
                    break;
                case -2:
                    lazyVal -= cgValueModifiers.Value_Rook;
                    lazyVal -= cgValueModifiers.Positions_Rook[i];
                    break;
                case -3:
                    lazyVal -= cgValueModifiers.Value_Knight;
                    lazyVal -= cgValueModifiers.Positions_Knight[i];
                    break;
                case -4:
                    lazyVal -= cgValueModifiers.Value_Bishop;
                    lazyVal -= cgValueModifiers.Positions_Bishop[i];
                    break;
                case -5:
                    lazyVal -= cgValueModifiers.Value_Queen;
                    break;
                case -6:
                    lazyVal -= cgValueModifiers.Value_King;
                    break;
            }
        }
        //add castling rights as value.
        if (longCastlingRights(true)) lazyVal += cgValueModifiers.Value_CastlingLongRights;
        if (longCastlingRights(false)) lazyVal -= cgValueModifiers.Value_CastlingLongRights;

        if (shortCastlingRights(true)) lazyVal += cgValueModifiers.Value_CastlingShortRights;
        if (shortCastlingRights(false)) lazyVal -= cgValueModifiers.Value_CastlingShortRights;

        if (blackHasCastled) lazyVal -= cgValueModifiers.Value_Castle;
        if (whiteHasCastled) lazyVal += cgValueModifiers.Value_Castle;
        return lazyVal;
    }

    #region moves
    private cgMoveSet _findMoveSetFor(int piece, int indexPosition)
    {
        if (piece < 0 && piece != -1) piece = Mathf.Abs(piece);
        return allHypotheticalMoves[piece.ToString() + indexPosition.ToString()];

    }

    /// <summary>
    /// Final verification, checks if the kings is attempting to perform a capture that leads to the king being taken next, which is the only illegal move findLegalMoves does not check.
    /// </summary>
    /// <param name="testMove">The move to be verified</param>
    /// <returns>Is this an illegal king capture?</returns>
    public bool verifyLegality(cgSimpleMove testMove)
    {
        if (testMove.to == 65) return false;
        else if (Mathf.Abs(squares[testMove.from]) != 6) return true;
        else
        {
            move(testMove);
            foreach (cgSimpleMove mov in findLegalMoves(_whiteTurnToMove))
            {
                if (mov.to == testMove.to)
                {
                    revert();
                    return false;
                }
            }
            revert();
            return true;
        }


    }

    /// <summary>
    /// Returns all legal moves for the provided color for the current board.
    /// Note: it may return a move in which the king captures an enemy piece to which the enemy can then next capture the king, use findStrictLegalMoves to avoid - however for the engine the computation to verify such a move are too costly.
    /// </summary>
    /// <param name="asWhite">Move as white?</param>
    /// <returns>All legal moves for provided color</returns>
    public List<cgSimpleMove> findLegalMoves(bool asWhite)
    {

        List<cgSimpleMove> legalMoves = new List<cgSimpleMove>();
        List<cgSimpleMove> enemyMoves = new List<cgSimpleMove>();

        bool check = false;
        _enPassantSquare = 65;
        _enPassantCapturesOn = 65;

        //test if there's an en passant opportunity.
        if (moves.Count > 0 && moves[moves.Count - 1].to != 65)
        {
            if (Mathf.Abs(squares[moves[moves.Count - 1].to]) == 1)
            {
                //its a pawn
                if (Mathf.Abs(moves[moves.Count - 1].from - moves[moves.Count - 1].to) == 16)
                {
                    //pawn did a double move the last move, this means we got ourselves an enpassant opportunity.
                    _enPassantSquare = (byte)(moves[moves.Count - 1].from + ((moves[moves.Count - 1].to >= 32) ? -8 : 8));
                    _enPassantCapturesOn = moves[moves.Count - 1].to;
                }
            }
        }
        for (int i = 0; i < squares.Count; i++)
        {
            int piece = squares[i];
            if ((piece > 0 && asWhite) || (piece < 0 && !asWhite))
            {
                cgMoveSet allPotentialeMoves = _findMoveSetFor(piece, i);
                //UnityEngine.Debug.Log("Moves:" + moves);
                if (allPotentialeMoves != null)
                {
                    legalMoves.AddRange(removeIllegalMoves(allPotentialeMoves));
                }
            }
            else if (piece != 0)
            {
                //piece is not empty and is not same colour as moving player.
                enemyMoves.AddRange(removeIllegalMoves(_findMoveSetFor(piece, i)));
            }
            //legalMoves.AddRange(weakLegalMoves);
        }

        //examine whether castling is possible, first by seeing if castling rights exist(i.e king and rooks hasnt moved).
        bool shortCastling = shortCastlingRights(asWhite);
        bool longCastling = longCastlingRights(asWhite);

        //second by seing if rooks have been captured or not.
        if (shortCastling) shortCastling = asWhite ? squares[63] == 2 : squares[7] == -2;
        if (longCastling) longCastling = asWhite ? squares[56] == 2 : squares[0] == -2;
        //thirdly see if the squares necessary for castling are unoccupied.
        if (asWhite && shortCastling) shortCastling = (squares[61] == 0 && squares[62] == 0) ? true : false;
        else if (!asWhite && shortCastling) shortCastling = (squares[5] == 0 && squares[6] == 0) ? true : false;
        if (asWhite && longCastling) longCastling = (squares[58] == 0 && squares[59] == 0 && squares[57] == 0) ? true : false;
        else if (!asWhite && longCastling) longCastling = (squares[2] == 0 && squares[3] == 0 && squares[1] == 0) ? true : false;

        foreach (cgSimpleMove move in enemyMoves)
        {
            if (Mathf.Abs(squares[move.to]) == 6)
            {
                //there is an enemy move attacking our king. We cannot castle now and we have to deal with this check.
                check = true;
                shortCastling = false;
                longCastling = false;
            }
            //check if any enemy move which is attacking a non-king piece of mine is on a ray that leads to my king, to see if any of my pieces are pinned and thusly illegal to move out of said ray.
            else if (Mathf.Abs(squares[move.to]) != 0)
            {
                List<byte> ray = _getFullRayFor(_findMoveSetFor(squares[move.from], move.from), move.to);
                if (ray != null)
                {
                    byte hitsAlongRay = 0;
                    sbyte hasHitAtIndex = -1;
                    for (byte b = 0; b < ray.Count; b++)
                    {
                        if ((squares[ray[b]] == 6 && squares[move.from] < 0) || (squares[ray[b]] == -6 && squares[move.from] > 0))
                        {
                            //on a ray attacking my king.
                            hasHitAtIndex = (sbyte)b;
                            break;
                        }
                        else if ((squares[ray[b]] > 0 && squares[move.from] < 0) || (squares[move.from] > 0 && squares[ray[b]] < 0))
                        {
                            //count a piece on the ray.
                            hitsAlongRay++;
                        }

                    }

                    //this enemy move is on a ray to attack my king, and its only being blocked by one piece(hitsalongray == 1) - so that piece is pinned and cannot move, so we delete all its mvoes(except any move it can make that captures the enemy piece or moves that are on the ray between king and attacking piece).
                    if (hasHitAtIndex != -1 && hitsAlongRay == 1)
                    {
                        ray.RemoveRange(hasHitAtIndex, ray.Count - hasHitAtIndex);
                        for (byte c = (byte)(legalMoves.Count - 1); c > 0; c--)
                        {
                            if (ray.Contains(legalMoves[c].from))
                            {
                                if (!ray.Contains(legalMoves[c].to) && legalMoves[c].to != move.from) legalMoves.RemoveAt(c);
                            }
                        }
                    }

                }
            }
            //disallowing castling(if its not already disallowed) if any enemy move attacks any castlign square
            if (shortCastling)
            {
                if (asWhite)
                {
                    if (move.to == 61 || move.to == 62) shortCastling = false;
                }
                else if (!asWhite)
                {
                    if (move.to == 5 || move.to == 6) shortCastling = false;
                }
            }
            if (longCastling)
            {
                if (asWhite)
                {
                    if (move.to == 58 || move.to == 59) longCastling = false;
                }
                else if (!asWhite)
                {
                    if (move.to == 2 || move.to == 3) longCastling = false;
                }
            }
        }
        //We've jumped through 5 hoops to test the legality of castling, if shortcastling or longcastling is still true, we're in the clear.
        if (longCastling && asWhite) legalMoves.Add(new cgCastlingMove(60, 58, cgValueModifiers.AlphaBeta_Weight_LongCastle, 56, 59));
        else if (longCastling && !asWhite) legalMoves.Add(new cgCastlingMove(4, 2, cgValueModifiers.AlphaBeta_Weight_LongCastle, 0, 3));
        if (shortCastling && asWhite) legalMoves.Add(new cgCastlingMove(60, 62, cgValueModifiers.AlphaBeta_Weight_ShortCastle, 63, 61));
        else if (shortCastling && !asWhite) legalMoves.Add(new cgCastlingMove(4, 6, cgValueModifiers.AlphaBeta_Weight_ShortCastle, 7, 5));
        legalMoves.Sort(delegate(cgSimpleMove x, cgSimpleMove y)
        {
            return x.positionalVal.CompareTo(y.positionalVal);
        });
        legalMoves.Reverse();

        //check if any king move is illegal(if it would move to a square an enemy may attack).
        for (short b = (short)(legalMoves.Count); b > 0; b--)
        {
            if (Mathf.Abs(squares[legalMoves[b - 1].from]) == 6)
            {
                foreach (cgSimpleMove mov in enemyMoves)
                {

                    if (mov.to == legalMoves[b - 1].to && Mathf.Abs(squares[mov.from]) != 1)
                    {
                        legalMoves.RemoveAt(b - 1);
                        break;
                    }
                }
            }
        }

        //to make certain the engine gets to check.
        if (legalMoves.Count == 0) legalMoves.Add(new cgSimpleMove(65, 65));
        //since there are no enemy moves checking my king we return all legal moves(note legal moves may still contain illegal moves that lead to my king captured next- which is illegal in chess).
        if (!check) return legalMoves;
        else if (check)
        {
            //there is atleast one enemy move currently checking my king. :(
            List<cgSimpleMove> checkingMoves = new List<cgSimpleMove>();
            foreach (cgSimpleMove movve in enemyMoves) if (Mathf.Abs(squares[movve.to]) == 6) checkingMoves.Add(movve);
            if (checkingMoves.Count == 1)
            {
                //as the king is only attacked by a single enemy move we may capture said single piece or block the path(if its a ray i.e attacking piece is not a knight or is not adjacent to the king)
                List<byte> legalMoveToSquares = _getBlockAttackSquares(checkingMoves[0]);
                for (int u = legalMoves.Count; u > 0; u--)
                {
                    if (legalMoves[u - 1].to == 65) continue;
                    if (!legalMoveToSquares.Contains(legalMoves[u - 1].to) && Mathf.Abs(squares[legalMoves[u - 1].from]) != 6)
                    {
                        legalMoves.RemoveAt(u - 1);
                    }
                }
            }
            else
            {
                //King is attacked by more than 1 enemy move, we have to move the king or lose.
                for (int u = legalMoves.Count; u > 0; u--)
                {
                    if (legalMoves[u-1].from<65&&Mathf.Abs(squares[legalMoves[u - 1].from]) != 6) legalMoves.RemoveAt(u - 1);
                }
            }

        }

        //to make certain the engine gets to check.
        if (legalMoves.Count == 0) legalMoves.Add(new cgSimpleMove(65, 65));

        return legalMoves;
        //UnityEngine.Debug.Log("Legal moves:" + legalMoves.Count);
    }

    /// <summary>
    /// Returns all legal moves for the provided color for the current board.
    ///
    /// </summary>
    /// <param name="asWhite">Move as white?</param>
    /// <returns>All legal moves for provided color</returns>
    public List<cgSimpleMove> findStrictLegalMoves(bool asWhite)
    {
        List<cgSimpleMove> legalMoves = findLegalMoves(asWhite);
        for (int i = legalMoves.Count; i > 0; i--)
        {
            if (!verifyLegality(legalMoves[i - 1])) legalMoves.RemoveAt(i - 1);
        }
        return legalMoves;

    }
    /// <summary>
    /// Returns all squares the block the provided move.
    /// </summary>
    /// <param name="forMove">The move that should be blocked</param>
    /// <returns>The squares that block the move.</returns>
    private List<byte> _getBlockAttackSquares(cgSimpleMove forMove)
    {
        List<byte> returns = new List<byte>();

        returns.Add(forMove.from);
        int type = Mathf.Abs(squares[forMove.from]);
        if (type == 2 || type == 4 || type == 5)
        {
            returns.AddRange(_getRayIn(_findMoveSetFor(type, forMove.from), forMove.to));
        }
        return returns;
    }

    /// <summary>
    /// Finds the ray in provided moveset that leads to provided destination.
    /// </summary>
    /// <param name="mset">The moveset to search.</param>
    /// <param name="to">The destination to find.</param>
    /// <returns>The ray that leads to the destination.</returns>
    private List<byte> _getRayIn(cgMoveSet mset, byte to)
    {
        byte startORay = 0;
        byte endORay = 0;
        for (byte i = 0; i < mset.moves.Count; i++)
        {
            if (mset.moves[i] == -1) startORay = i;
            else if (mset.moves[i] == to)
            {
                endORay = i;
                break;
            }
        }
        List<byte> returns = new List<byte>();
        for (int u = startORay; u < (endORay); u++)
        {
            returns.Add((byte)mset.moves[u]);
        }
        return returns;
    }

    /// <summary>
    /// Gets full ray(not cut at destination) in moveset that includes index position.
    /// </summary>
    /// <param name="set">The moveset to search</param>
    /// <param name="includesIndex">The index to find</param>
    /// <returns>the full ray that includes the index position</returns>
    private List<byte> _getFullRayFor(cgMoveSet set, byte includesIndex)
    {
        byte startOfRay = 0;
        byte endOfRay = 65;
        bool hitRay = false;
        if (set.type != 2 && set.type != 4 && set.type != 5) return null;
        for (byte i = 0; i < set.moves.Count; i++)
        {
            if (set.moves[i] == -1 && !hitRay) startOfRay = (byte)(i + 1);
            else if (set.moves[i] == -1 && hitRay)
            {
                endOfRay = (byte)(i);
                break;
            }
            if (set.moves[i] == includesIndex) hitRay = true;
        }
        if (!hitRay) return null;
        else
        {
            List<byte> ray = new List<byte>();
            for (int u = startOfRay; u < endOfRay; u++) if (set.moves[u] > -1) ray.Add((byte)set.moves[u]);

            //Debug.Log("retrieving entire ray for type:" + set.type + " searching for:" + includesIndex + " found at:" + startOfRay + " to:" + endOfRay + " we hit the ray:" + hitRay);
            //Debug.Log("ray length: " + ray.Count);
            return ray;
        }
    }
    /// <summary>
    /// Examines a moveset(all moves for a piece on a given square), and removes all illegal moves in this moveset based on the current board.
    /// </summary>
    /// <param name="moveSet">The moveset to examine</param>
    /// <returns>All unblocked moves</returns>
    private List<cgSimpleMove> removeIllegalMoves(cgMoveSet moveSet)
    {
        List<cgSimpleMove> returns = new List<cgSimpleMove>();
        bool asWhite = squares[moveSet.from] > 0 ? true : false;
        bool rayGoing = true;
        bool canAttack = (moveSet.type == -1 || moveSet.type == 1) ? false : true;
        bool canMove = true;
        for (int i = 0; i < moveSet.moves.Count; i++)
        {
            if (moveSet.type == 3 || moveSet.type == 6) rayGoing = true; //add knight or king moves regardless of ray.
            if (moveSet.moves[i] == -1)
            {
                rayGoing = true;
                continue;
            }
            if (moveSet.moves[i] == -2)
            {
                //-2 signifies the beginning of attack only moves(pawn's forward diagonal attacks)
                canAttack = true;
                canMove = false;
                continue;
            }
            if (rayGoing || !canMove)
            {
                if (squares[moveSet.moves[i]] == 0 && canMove) returns.Add(new cgSimpleMove(moveSet.from, (byte)moveSet.moves[i], moveSet.positionalValues[i]));
                else if ((squares[moveSet.moves[i]] > 0 && !asWhite) || (squares[moveSet.moves[i]] < 0 && asWhite))
                {
                    if (canAttack)
                    {
                        //If I am white and attacking a black piece then I can take, or if I am black and attacking a white I can take - (Unless I'm a pawn);
                        returns.Add(new cgSimpleMove(moveSet.from, (byte)moveSet.moves[i], cgValueModifiers.AlphaBeta_Weight_Capture));
                        if (Mathf.Abs(squares[moveSet.moves[i]]) == 6) returns[returns.Count - 1].positionalVal = cgValueModifiers.AlphaBeta_Weight_Check;
                        //UnityEngine.Debug.Log("piece on" + moveSet.from + " takes on" + moveSet.moves[i]+" as white: "+asWhite+" piece on destination:"+_board.squares[moveSet.moves[i]]);
                        //continue;
                    }
                    rayGoing = false; //cannot continue further down this ray.

                    continue;
                }
                //test if an en passant move is possible
                else if (squares[moveSet.moves[i]] == 0 && canAttack && !canMove && _enPassantSquare == moveSet.moves[i]) returns.Add(new cgEnPassantMove(moveSet.from, (byte)moveSet.moves[i], cgValueModifiers.AlphaBeta_Weight_Capture, _enPassantCapturesOn));

                else if ((squares[moveSet.moves[i]] > 0 && asWhite) || (squares[moveSet.moves[i]] < 0 && !asWhite))
                {
                    //Black on black or white on white. Cannot make the move, and am now blocked from going further down this ray.
                    rayGoing = false;
                    continue;
                }
            }
        }
        return returns;
    }

    /// <summary>
    /// There are 3896 unique moves for any piece on any given square on an otherwise unoccupied board, we will generate all these moves once here and then look these up later when needed.
    /// This saves a huge amount of computation when we are generating millions of moves for deep analysis later on.
    /// </summary>
    private void _generateAllPossibleMoves()
    {
        allHypotheticalMoves = new Dictionary<string, cgMoveSet>();
        for (int i = 0; i < 64; i++)
        {
            allHypotheticalMoves["5" + i.ToString()] = new cgMoveSet(cgMoveGenerator.EmulateQueenAt(i), i, 5); ;
            allHypotheticalMoves["2" + i.ToString()] = new cgMoveSet(cgMoveGenerator.EmulateRookAt(i), i, 2);
            allHypotheticalMoves["4" + i.ToString()] = new cgMoveSet(cgMoveGenerator.EmulateBishopAt(i), i, 4);
            allHypotheticalMoves["3" + i.ToString()] = new cgMoveSet(cgMoveGenerator.EmulateKnightAt(i), i, 3);
            allHypotheticalMoves["6" + i.ToString()] = new cgMoveSet(cgMoveGenerator.EmulateKingAt(i), i, 6);

            //we ignore the starting row and the last row for pawns, as they either start in front of it, or get a promotion immediately when arriving on it.
            allHypotheticalMoves["1" + i.ToString()] = new cgMoveSet(cgMoveGenerator.EmulatePawnAt(i, true), i, 1);
            allHypotheticalMoves["-1" + i.ToString()] = new cgMoveSet(cgMoveGenerator.EmulatePawnAt(i, false), i, -1);
        }
        //UnityEngine.Debug.Log("dict:" + allHypotheticalMoves["544"].from + "moves count:" + allHypotheticalMoves["544"].moves.Count);

        //UnityEngine.Debug.Log("total number of unique squares for each piece:" + allHypotheticalMoves.Count);
    }
    #endregion

    #region read / paste
    /// <summary>
    /// Generates a board matching the provided notation.
    /// </summary>
    /// <param name="notation">The notation of the game to be recreated</param>
    public void LoadGame(cgNotation notation)
    {
        foreach (cgSimpleMove newmove in notation.moves)
        {
            List<cgSimpleMove> nmoves = findLegalMoves(_whiteTurnToMove);
            bool found = false;
            foreach (cgSimpleMove safemove in nmoves)
            {
                if (safemove.to == newmove.to && safemove.from == newmove.from)
                {
                    move(safemove);
                    found = true;
                }
            }
            if (!found)
            {
                Debug.Log("couldn't find: " + cgGlobal.MoveToString(newmove));
                move(newmove);
            }
        }
    }
    #endregion

    /// <summary>
    /// Is the color checked?
    /// </summary>
    /// <param name="asWhite">Should we check if white is checked(true) or if black is checked(false)</param>
    /// <returns>Is the color checked?</returns>
    public bool isChecked(bool asWhite)
    {
        foreach (cgSimpleMove mov in findLegalMoves(!asWhite))
        {
            if (Mathf.Abs(squares[mov.to]) == 6) return true;
        }

        return false;
    }
}
